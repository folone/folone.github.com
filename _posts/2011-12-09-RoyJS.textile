---
layout: post
title: Roy, статически типизированный джаваскрипт.
comments: true
is: post
categories: 
- javascript
- emacs
- scala
- roy
- fp
---

Каждый раз начиная новый проект под веб, стоит проблема выбора стека технологий. Для меня сервер-сайд технологии более-менее определены (планирую поменять "lift":http://liftweb.net/ на "play":http://scala.playframework.org/, но это мелочи). Тем не менее, UI -- это каждый раз компромисс. Так хочется статически-типизированный язык. Тем не менее, по отзывам, с вариантами вроде GWT "и иже с ним":https://vaadin.com/home проблем во время дебага не оберёшься.

На новом проекте я наконец решил заюзать что-нибудь эдакое. После некоторого "ресёрча":http://altjs.org/ выбрал "Roy":http://roy.brianmckenna.org/. Уверен, с этим выбором будет связано множество недовольств в команде: язык очень молодой, поддерживается парой энтузиастов и вообще выглядит непривычно для среднестатистического веб-девелопера. Тем не менее, статическая типизация, синтаксис, похожий на хаскелль, паттерн матчинг, do-нотация, вызовы к сторонним библиотекам (правда, пока такие вызовы не типизированы) и вывод типов с помощью алгоритма "Хиндли-Милнера":http://en.wikipedia.org/wiki/Hindley%E2%80%93Milner взяли своё. К тому же, на выходе получается вполне вменяемый и читаемый (!) джаваскрипт. Что значит, что если вдруг не приживётся, выкинуть будет очень просто.

!http://spl.smugmug.com/Humor/Lambdacats/unsafe/960526434_XbHXq-M-1.jpg!:http://spl.smugmug.com/Humor/Lambdacats/13227630_j2MHcg#960526434_XbHXq

Так как язык очень молодой, пришлось делать периферийную работу:
Первым, что я сделал -- на скорую руку склепал "roy-mode":https://github.com/folone/roy-mode. Делал на основе "generic-mode":http://www.emacswiki.org/emacs/GenericMode, что оказалось весьма простым занятием:

<script src="https://gist.github.com/1447544.js?file=gistfile1.el"></script>

Строки вида @"\\<\\(e\\(?:mpty\\|ven\\)\\|f\\(?:ilter\\|lip\\|oldl\\)\\|head\\|id\\|l..."@ -- регулярные выражения. Получить их можно с помощью функции "regexp-opt":http://www.emacswiki.org/emacs/RegexpOpt (тут они просто вставлены в код по причине того, что в туториалах пишут, что так должно работать быстрей).

Получилось что-то такое:
!http://i.imgur.com/hf3aJ.png!

Над модом ещё работать и работать: нету поддержки компилятора, автоотступов, етс (читай: "pull requests are very welcome"). Тем не менее, после того как я обзавёлся каким-никаким методом ввода кода, пришло время автоматизировать компиляцию этого самого кода. Так как сборка на наших проектах производится мейвеном, был быстренько написан "плагин":https://github.com/folone/roy-maven-plugin. Благодаря пакету "@scala.sys.process@":http://www.scala-lang.org/archives/downloads/distrib/files/nightly/docs/library/scala/sys/process/ProcessBuilder.html, включающему в себя удобный DSL для описания shell-команд, код получился весьма небольшим и довольно читабельным.
Получаем все roy-файлы в директории:

{% highlight scala %}
private def recursiveListFiles(f: File, r: Regex) = {
  val these = f.listFiles
  val good = these.filter(f => r.findFirstIn(f.getName).isDefined)
  good ++ these.filter {_.isDirectory}.flatMap {recursiveListFiles(_, r)}
}

val filesToCompile = recursiveListFiles(in, """.*\.roy$""".r)
{% endhighlight %}

Компилим каждый и перекидываем результат в директорию с джаваскриптом:

{% highlight scala %}
private def compileFile(o: File)(f: File) = {
  val result = ("roy " + f.getPath) !
  val jsFile = new File(fileExtToJs(f.getPath))
  jsFile.renameTo(new File(o, jsFile.getName))
  result
}

private def fileExtToJs(roy: String) =
  roy.split('.').init :+ "js" mkString "."

filesToCompile foreach { compileFile(out) }
{% endhighlight %}

Оператор @!@ выполняет последовательность shell-команд и возвращает код выхода. Если же нужен текстовый вывод последовательности, можно использовать оператор @!!@.

Понятное дело, и roy-mode'у и мейвен-плагину для корректной работы нужен установленный roy: @npm install roy@.

Итого, инфраструктура в зачаточном состоянии есть. Надеюсь, roy сможет решить главную возложенную на него задачу: помочь получать наконец удовольствие от UI-разработки под веб.
