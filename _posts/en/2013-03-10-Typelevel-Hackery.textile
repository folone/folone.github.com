---
layout: post
title: Typelevel hackery tricks in Scala
comments: true
is: post
categories:
- scala
- en
- types
- shapeless
- fp
---

There's a lot of talks about typelevel things in Scala. "Shapeless":shapeless has gained huge amount of attention lately. There are a lot of cool typelevel tricks out there, coined by "Miles Sabin":milessabin, the type astonaut. Some even say, he does not exist at the runtime. Anyway, I'd like to collect some of those tricks here, for future reference. I'm also doing this to get a better understanding of those tricks.

h2. Table

table{border:1px solid black}.
|_.Trick|_.Short description|
|"Unboxed Tagged Types":taggedtypes|Something like Haskell's "newtype":newtype, but better.|
|"Dependent types":deptypestaste|Have types depend on values|
|"Unapply":unapplyscalaz|Reduce needed type annotations by guiding scala's type inference|
|"Ambiguous implicits":ambigimplicitsml|A way to guarantee that a polymorphic function will not return some specific type|

h2. Unboxed Tagged Types

There's already a great explanation, including the needed intuition, in "Eric Torreborre's blog":taggedtypes. This technique allows for having some typelevel guarantees on the values. Here's a motivating example. Say, you want to create a function, which operates on positive doubles. Here's how you could go about this:

{% highlight scala %}
def log(i: Double): Option[Double] =
    if(i > 0) scala.math.log(i)
    else None
{% endhighlight %}

It's a totally ok way to do this, but imagine, you want several such functions, and you want to chain them afterwards. You might create something like

{% highlight scala %}
def positive(i: Double): Option[Double] =
    if(i > 0) Some(i) else None

def log(i: Double) = scala.math.log(i)

//positive(x) map log map func2 ...
{% endhighlight %}

Let's try that out:

{% highlight scala %}
scala> positive(5) map log
res0: Option[Double] = Some(1.6094379124341003)

scala> positive(-1) map log
res1: Option[Double] = None
{% endhighlight %}

But what would prevent someone from just

{% highlight scala %}
scala> log(-1)
res2: Double = NaN
{% endhighlight %}

You would probably like to  express your intents in types, if possible trying not to overuse single-valued case-classes and boxing/unboxing values. Here's a possible solution:

{% highlight scala %}
import scalaz._, Scalaz._
trait Positive
def positive(i: Double): Option[Double @@ Positive] =
    if(i > 0) Some(Tag[Double, Positive](i)) else None

def log(i: Double @@ Positive) = scala.math.log(i)

//positive(x) map log map func2 ...
{% endhighlight %}

Here @positive@ is the so-called smart constructor. Let's try it out. As before:

{% highlight scala %}
scala> positive(5) map log
res1: Option[Double] = Some(1.6094379124341003)

scala> positive(-1) map log
res2: Option[Double] = None
{% endhighlight %}

But now:

{% highlight scala %}
scala> log(-1.0)
<console>:16: error: type mismatch;
 found   : Double(-1.0)
 required: scalaz.package.@@[Double,Positive]
              log(-1.0)
                   ^
{% endhighlight %}

"Here's":taggedscalaz an implementation of this thing in scalaz. Scalaz uses this technique a lot, specifically for differentiating between different typeclass instances for the same type. For example, there are different semigroups for "Int":intsemi (default, under addition), "Int @@ Multiplication":intmulsemi, "Int @@ MaxValue":intmaxsemi, "Int @@ MinValue":intminsemi.

h2. Dependent types

With the next scala version and some shapeless magic stuff like this is possible:

{% highlight scala %}
scala> import shapeless.SingletonTypes._
import shapeless.SingletonTypes._

scala> val evidence: ^(5.0 > 0) = true
evidence: Boolean(true) = true

scala> val evidence: ^(-1.0 > 0) = true
<console>:13: error: type mismatch;
 found   : Boolean(true)
 required: Boolean(false)
       val evidence: ^(-1.0 > 0) = true
                                 ^
{% endhighlight %}

I was not able to push it to the level of functions though:

{% highlight scala %}
scala> def positive(res: Double): Double = {
     |     val evidence: ^(res > 0) = true
     |     res
     | }
error: exception during macro expansion: 
scala.tools.reflect.ToolBoxError: reflective compilation has failed: 

object > is not a member of package res
	at scala.tools.reflect.ToolBoxFactory$ToolBoxImpl$ToolBoxGlobal.throwIfErrors(ToolBoxFactory.scala:314)
	at scala.tools.reflect.ToolBoxFactory$ToolBoxImpl$ToolBoxGlobal.compile(ToolBoxFactory.scala:250)
	at scala.tools.reflect.ToolBoxFactory$ToolBoxImpl.compile(ToolBoxFactory.scala:409)
	at scala.tools.reflect.ToolBoxFactory$ToolBoxImpl.eval(ToolBoxFactory.scala:412)
	at scala.reflect.macros.contexts.Evals$class.eval(Evals.scala:16)
	at scala.reflect.macros.contexts.Context.eval(Context.scala:6)
	at shapeless.SingletonTypeMacros$class.eval(snat.scala:40)
	at <macroinvokers>.SingletonTypeMacros_invoker_2107abc6e1de498e8212e5249a547bda.eval(compileLateSynthetic-0480dadcf9774235b72d647816247166.scala:37)
	at shapeless.SingletonTypeMacros$class.singletonType(snat.scala:44)
	at <macroinvokers>.SingletonTypeMacros_invoker_2107abc6e1de498e8212e5249a547bda.singletonType(compileLateSynthetic-0480dadcf9774235b72d647816247166.scala:37)
{% endhighlight %}

Anyway, this makes typelevel hanoi towers "extremely easy":hanoitl.

<blockquote class="twitter-tweet" lang="ru"><p>@<a href="https://twitter.com/folone">folone</a> @<a href="https://twitter.com/aloiscochard">aloiscochard</a> Back when *I* did crazy things at the type level, we had to walk uphill both ways, in the snow. Get off my lawn!</p>&mdash; Travis Brown (@travisbrown) <a href="https://twitter.com/travisbrown/status/307503582993854465">1.02.2013</a></blockquote>
<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

h2. Ambiguous implicits

Enforcing that we don't get a specified return type.
<script src="https://gist.github.com/milessabin/c9f8befa932d98dcc7a4.js"></script>
As "pointed out":specificambig by Miles, this works because the ambiguous implicits (@nsubAmbig1@ and @nsubAmbig2@) are more specific ("specification":scalaspec).

h2. Unapply trick

I've recently answered one of the "SO questions":sounapply, using this technique. "Here's":unapplyscalaz the implementation in scalaz repo. The trick allows for reducing the number of type annotations by guiding scala's type inference.

[shapeless]https://github.com/milessabin/shapeless
[taggedtypes]http://etorreborre.blogspot.de/2011/11/practical-uses-for-unboxed-tagged-types.html
[taggedscalaz]https://github.com/scalaz/scalaz/blob/scalaz-seven/core/src/main/scala/scalaz/Tag.scala
[intsemi]https://github.com/scalaz/scalaz/blob/scalaz-seven/core/src/main/scala/scalaz/std/AnyVal.scala#L255
[intmulsemi]https://github.com/scalaz/scalaz/blob/scalaz-seven/core/src/main/scala/scalaz/std/AnyVal.scala#L285
[intmaxsemi]https://github.com/scalaz/scalaz/blob/scalaz-seven/core/src/main/scala/scalaz/Semigroup.scala#L95
[intminsemi]https://github.com/scalaz/scalaz/blob/scalaz-seven/core/src/main/scala/scalaz/Semigroup.scala#L89
[milessabin]https://twitter.com/milessabin
[hanoitl]https://gist.github.com/folone/4946543
[taggedtypes]http://etorreborre.blogspot.de/2011/11/practical-uses-for-unboxed-tagged-types.html
[ambigimplicitsml]https://groups.google.com/forum/?fromgroups=#!topic/scala-language/4SQt-n1l9Zk
[ambigImplicit]https://gist.github.com/milessabin/c9f8befa932d98dcc7a4
[unapplyscalaz]https://github.com/scalaz/scalaz/blob/scalaz-seven/core/src/main/scala/scalaz/Unapply.scala
[deptypestaste]https://gist.github.com/folone/4945168
[newtype]http://www.haskell.org/haskellwiki/Newtype
[scalaspec]http://www.scala-lang.org/docu/files/ScalaReference.pdf
[sounapply]http://stackoverflow.com/questions/15294966/is-is-possible-to-improve-type-inference-for-partially-applied-types-in-scala/15299148#15299148
[specificambig]https://groups.google.com/d/msg/scala-language/4SQt-n1l9Zk/xjNnM2g82swJ
