
<!-- saved from url=(0092)http://web.archive.org/web/20100630195449/http://homepage.mac.com/sigfpe/Computing/diff.html -->
<html autopagermatchedrules="1"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Differentiation of Datastructures for Non-Functional Programmers</title>
<meta name="Generator" content="Vim/6.2">
<style type="text/css"></style></head>
<body bgcolor="#ffffff" text="#000000"><div id="wm-ipp" style="display: none; position: relative; padding: 0px 5px; min-height: 70px; min-width: 800px; z-index: 9000; ">
<div id="wm-ipp-inside" style="position:fixed;padding:0!important;margin:0!important;width:97%;min-width:780px;border:5px solid #000;border-top:none;background-image:url(http://staticweb.archive.org/images/toolbar/wm_tb_bk_trns.png);text-align:center;-moz-box-shadow:1px 1px 3px #333;-webkit-box-shadow:1px 1px 3px #333;box-shadow:1px 1px 3px #333;font-size:11px!important;font-family:&#39;Lucida Grande&#39;,&#39;Arial&#39;,sans-serif!important;">
   <table style="border-collapse:collapse;margin:0;padding:0;width:100%;"><tbody><tr>
   <td style="padding:10px;vertical-align:top;min-width:110px;">
   <a href="http://wayback.archive.org/web/" title="Wayback Machine home page" style="background-color:transparent;border:none;"><img src="./Differentiation of Datastructures for Non-Functional Programmers_files/wayback-toolbar-logo.png" alt="Wayback Machine" width="110" height="39" border="0"></a>
   </td>
   <td style="padding:0!important;text-align:center;vertical-align:top;width:100%;">

       <table style="border-collapse:collapse;margin:0 auto;padding:0;width:570px;"><tbody><tr>
       <td style="padding:3px 0;" colspan="2">
       <form target="_top" method="get" action="http://wayback.archive.org/web/form-submit.jsp" name="wmtb" id="wmtb" style="margin:0!important;padding:0!important;"><input type="text" name="url" id="wmtbURL" value="http://homepage.mac.com/sigfpe/Computing/diff.html" style="width:400px;font-size:11px;font-family:&#39;Lucida Grande&#39;,&#39;Arial&#39;,sans-serif;" onfocus="javascript:this.focus();this.select();"><input type="hidden" name="type" value="replay"><input type="hidden" name="date" value="20100630195449"><input type="submit" value="Go" style="font-size:11px;font-family:&#39;Lucida Grande&#39;,&#39;Arial&#39;,sans-serif;margin-left:5px;"><span id="wm_tb_options" style="display:block;"></span></form>
       </td>
       <td style="vertical-align:bottom;padding:5px 0 0 0!important;" rowspan="2">
           <table style="border-collapse:collapse;width:110px;color:#99a;font-family:&#39;Helvetica&#39;,&#39;Lucida Grande&#39;,&#39;Arial&#39;,sans-serif;"><tbody>
			
           <!-- NEXT/PREV MONTH NAV AND MONTH INDICATOR -->
           <tr style="width:110px;height:16px;font-size:10px!important;">
           	<td style="padding-right:9px;font-size:11px!important;font-weight:bold;text-transform:uppercase;text-align:right;white-space:nowrap;overflow:visible;" nowrap="nowrap">
               
		                <a href="http://web.archive.org/web/20091217160827/http://homepage.mac.com/sigfpe/Computing/diff.html" style="text-decoration:none;color:#33f;font-weight:bold;background-color:transparent;border:none;" title="17 Dec 2009"><strong>DEC</strong></a>
		                
               </td>
               <td id="displayMonthEl" style="background:#000;color:#ff0;font-size:11px!important;font-weight:bold;text-transform:uppercase;width:34px;height:15px;padding-top:1px;text-align:center;" title="You are here: 19:54:49 Jun 30, 2010">JUN</td>
				<td style="padding-left:9px;font-size:11px!important;font-weight:bold;text-transform:uppercase;white-space:nowrap;overflow:visible;" nowrap="nowrap">
               
                       Jul
                       
               </td>
           </tr>

           <!-- NEXT/PREV CAPTURE NAV AND DAY OF MONTH INDICATOR -->
           <tr>
               <td style="padding-right:9px;white-space:nowrap;overflow:visible;text-align:right!important;vertical-align:middle!important;" nowrap="nowrap">
               
		                <a href="http://web.archive.org/web/20091217160827/http://homepage.mac.com/sigfpe/Computing/diff.html" title="16:08:27 Dec 17, 2009" style="background-color:transparent;border:none;"><img src="./Differentiation of Datastructures for Non-Functional Programmers_files/wm_tb_prv_on.png" alt="Previous capture" width="14" height="16" border="0"></a>
		                
               </td>
               <td id="displayDayEl" style="background:#000;color:#ff0;width:34px;height:24px;padding:2px 0 0 0;text-align:center;font-size:24px;font-weight: bold;" title="You are here: 19:54:49 Jun 30, 2010">30</td>
				<td style="padding-left:9px;white-space:nowrap;overflow:visible;text-align:left!important;vertical-align:middle!important;" nowrap="nowrap">
               
                       <img src="./Differentiation of Datastructures for Non-Functional Programmers_files/wm_tb_nxt_off.png" alt="Next capture" width="14" height="16" border="0">
                       
			    </td>
           </tr>

           <!-- NEXT/PREV YEAR NAV AND YEAR INDICATOR -->
           <tr style="width:110px;height:13px;font-size:9px!important;">
				<td style="padding-right:9px;font-size:11px!important;font-weight: bold;text-align:right;white-space:nowrap;overflow:visible;" nowrap="nowrap">
               
		                <a href="http://web.archive.org/web/20090422125408/http://homepage.mac.com/sigfpe/Computing/diff.html" style="text-decoration:none;color:#33f;font-weight:bold;background-color:transparent;border:none;" title="22 Apr 2009"><strong>2009</strong></a>
		                
               </td>
               <td id="displayYearEl" style="background:#000;color:#ff0;font-size:11px!important;font-weight: bold;padding-top:1px;width:34px;height:13px;text-align:center;" title="You are here: 19:54:49 Jun 30, 2010">2010</td>
				<td style="padding-left:9px;font-size:11px!important;font-weight: bold;white-space:nowrap;overflow:visible;" nowrap="nowrap">
               
                       2011
                       
				</td>
           </tr>
           </tbody></table>
       </td>

       </tr>
       <tr>
       <td style="vertical-align:middle;padding:0!important;">
           <a href="http://wayback.archive.org/web/20100630195449*/http://homepage.mac.com/sigfpe/Computing/diff.html" style="color:#33f;font-size:11px;font-weight:bold;background-color:transparent;border:none;" title="See a list of every capture for this URL"><strong>18 captures</strong></a>
           <div style="margin:0!important;padding:0!important;color:#666;font-size:9px;padding-top:2px!important;white-space:nowrap;" title="Timespan for captures of this URL">9 Sep 04 - 30 Jun 10</div>
       </td>
       <td style="padding:0!important;">
       <a style="position:relative; white-space:nowrap; width:450px;height:27px;" href="" id="wm-graph-anchor">
       <div id="wm-ipp-sparkline" style="position:relative; white-space:nowrap; width:450px;height:27px;background-color:#fff;cursor:pointer;border-right:1px solid #ccc;" title="Explore captures for this URL">
			<img id="sparklineImgId" style="position:absolute; z-index:9012; top:0px; left:0px;" onmouseover="showTrackers(&#39;inline&#39;);" onmouseout="showTrackers(&#39;none&#39;);" onmousemove="trackMouseMove(event,this)" alt="sparklines" width="450" height="27" border="0" src="./Differentiation of Datastructures for Non-Functional Programmers_files/graph.jsp">
			<img id="wbMouseTrackYearImg" style="display:none; position:absolute; z-index:9010;" width="25" height="27" border="0" src="./Differentiation of Datastructures for Non-Functional Programmers_files/transp-yellow-pixel.png">
			<img id="wbMouseTrackMonthImg" style="display:none; position:absolute; z-index:9011; " width="2" height="27" border="0" src="./Differentiation of Datastructures for Non-Functional Programmers_files/transp-red-pixel.png">
       </div>
		</a>

       </td>
       </tr></tbody></table>
   </td>
   <td style="text-align:right;padding:5px;width:65px;font-size:11px!important;">
       <a href="javascript:;" onclick="document.getElementById(&#39;wm-ipp&#39;).style.display=&#39;none&#39;;" style="display:block;padding-right:18px;background:url(http://staticweb.archive.org/images/toolbar/wm_tb_close.png) no-repeat 100% 0;color:#33f;font-family:&#39;Lucida Grande&#39;,&#39;Arial&#39;,sans-serif;margin-bottom:23px;background-color:transparent;border:none;" title="Close the toolbar">Close</a>
       <a href="http://faq.web.archive.org/" style="display:block;padding-right:18px;background:url(http://staticweb.archive.org/images/toolbar/wm_tb_help.png) no-repeat 100% 0;color:#33f;font-family:&#39;Lucida Grande&#39;,&#39;Arial&#39;,sans-serif;background-color:transparent;border:none;" title="Get some help using the Wayback Machine">Help</a>
   </td>
   </tr></tbody></table>

</div>
</div>

<h1>Saved from http://homepage.mac.com/sigfpe/Computing/diff.html<h1>

<h2>Differentiating Datastructures</h2>

<h3>The Algebra of Datatypes (for Non-Functional Programmers)</h3>
Many programming languages support the construction of new types from old.
For example in 'C' we may define

<blockquote>
<table width="75%">
<tbody><tr>
<td bgcolor="#CCFFFF">
<pre><tt>
typedef struct {
        <tt>A</tt> a;
        <tt>B</tt> b;
} AtimesB;
</tt></pre>
</td>
</tr>
</tbody></table>
</blockquote>

An object of type <tt>AtimesB</tt> contains both an object of type <tt>A</tt> and an object of type <tt>B</tt>. We will use a shorthand where we write this type as <tt>A.B</tt> or simply <tt>AB</tt>.

In C we can also introduce a new type as follows:

<blockquote>
<table width="75%">
<tbody><tr>
<td bgcolor="#CCFFFF">
<pre><tt>
typedef union {
        <tt>A</tt> a;
        <tt>B</tt> b;
} AplusB;
</tt></pre>
</td>
</tr>
</tbody></table>
</blockquote>

An <tt>AplusB</tt> contains either an object of type <tt>A</tt> or an object of type <tt>B</tt>. Unfortunately the union type in C has a major flaw. We can't actually tell whether or not an object of type AplusB contains an <tt>A</tt> or a <tt>B</tt>. In principle, however, we can add flag that indicates which it is. In C++ the boost library provides a boost variant type that maintains this information transparently. We can use a declaration like the following:
<blockquote>
<table width="75%">
<tbody><tr>
<td bgcolor="#CCFFFF">
<pre><tt>
typedef boost:variant&lt;A,B&gt; AplusB;
</tt></pre>
</td>
</tr>
</tbody></table>
</blockquote>

We'll carry on working with unions and pretend that they do contain a flag like a C++ variant.
<p>
As shorthand we will write this type as <tt>A+B</tt>. There is a slight subtlety with the type <tt>A+A</tt>. It's tempting to say an object of this type is clearly just an <tt>A</tt> so you might expect that <tt>A+A=A</tt>.
However, you can think of a sum of two types as having two slots, one of the type of the left argument and one of the type of the right argument.
Precisely one slot is filled and there is a flag to say which it is. In the case of <tt>A+A</tt>, although both slots have the same type, there is still the flag to indicate which of the two slots is filled.
</p><p>
Note that this algebraic notation makes sense and many of the standard rules of arithmetic have interpretations in terms of these types. For example <tt>A+B=B+A</tt> and <tt>A.B=B.A</tt> correspond to the fact that we can change the order of the members of the aboves structs and unions without making any essential difference.
Consider also <tt>A.(B+C)=A.B+A.C</tt>.
This also has a straightforward interpretation: an <tt>A</tt> and something that is either a <tt>B</tt> or a C is the same as an <tt>A</tt> and a <tt>B</tt> or an <tt>A</tt> and a <tt>C</tt>. Although one is a struct containing a variant and the other is a variant containing a struct it is trivial to write a short piece of code that converts one to the other. In fact, this is what we interpret = to mean - that there is a simple operation to convert the type on the left to the type on the right and vice versa. The types are isomorphic.
</p><p>
<tt>0</tt> is, by definition, a type that no object can have. (Imagine in C++ making the constructor private so nobody can use it.) The total number of objects of type <tt>0</tt> is therefore zero.
Consider the type <tt>B=A+0</tt>. An object of type <tt>B</tt> is either an object of type <tt>A</tt> or an object of type <tt>0</tt>.
By definition it can't be of type <tt>0</tt> so it must be of type <tt>A</tt>.
So <tt>B=A+0=A</tt>. Similarly <tt>0+A=A</tt>.
</p><p>
<tt>1</tt> is a type of which only one object exists. (These are often called singleton objects.)
All objects of type <tt>1</tt> are equal to each other.
So consider the type <tt>1+1</tt>.
Either one slot or the other is filled. Whichever it is it can only contain one value, the one object of type <tt>1</tt>.
On the other hand there is the flag indicating which of the two slots contains this unique object. So an object of type <tt>1+1</tt> can be in one of two possible states.
In other words there are two objects of type <tt>1+1</tt> and it's natural to name it <tt>2</tt>.
Any binary flag type is isomorphic to the type <tt>2</tt>.
Similarly we can define types corresponding to all of the integers by repeated addition of <tt>1</tt>. The type called <tt>n</tt>, where n is a natural number, is a type of which there exist precisely n possible objects. In C the enum type corresponds to these. For example 

</p><blockquote>
<table width="75%">
<tbody><tr>
<td bgcolor="#CCFFFF">
<pre><tt>
typedef enum {
        Zero,
        One,
	Two
} Three;
</tt></pre>
</td>
</tr>
</tbody></table>
</blockquote>

defines a type with three possible values and hence is isomorphic to <tt>3</tt>.
<p>
Now we can see even more correspondences with ordinary algebra.
Consider the type <tt>A.1</tt>.
It contains both an object of type <tt>A</tt> and the one object of type <tt>1</tt>.
As we already know what the object of type <tt>1</tt> is (there is only one after all) it is redundant.
So <tt>A.1=A</tt>. Consider an object of type <tt>A+A</tt>.
Whether it is the first or second slot that is filled we know the object contained in the slot is of type <tt>A</tt>.
So an object of type <tt>A+A</tt> consists of a flag and an object of type <tt>A</tt>. So we can rewrite this as <tt>2.A</tt>. So <tt>A+A=2.A</tt> as we might expect.
</p><p>
We will also use the power notation <tt>X<sup>n</sup></tt> as shorthand for <tt>X.X...n times...X</tt>. We find that the usual algebraic relationships hold.
For example it's a straightforward exercise to see that <tt>(X+Y)<sup>2</sup>=X<sup>2</sup>+2.X.Y+Y<sup>2</sup></tt>. In fact, <tt>X<sup>n</sup></tt> is nothing other than an array of n elements declared in C as:

</p><blockquote>
<table width="75%">
<tbody><tr>
<td bgcolor="#CCFFFF">
<pre><tt>
typedef X XpowerN[n];
</tt></pre>
</td>
</tr>
</tbody></table>
</blockquote>

There is another class of types we can introduce in C - the functions. For example

<blockquote>
<table width="75%">
<tbody><tr>
<td bgcolor="#CCFFFF">
<pre><tt>
A f(B);
</tt></pre>
</td>
</tr>
</tbody></table>
</blockquote>

declares a function that takes as argument an object of type <tt>B</tt> and returns an object of type <tt>A</tt>.
We write this type as <tt>A^B</tt> or <tt>A<sup>B</sup></tt>.
Note that we have used the power notation to mean something different to what we used it for above where it represents arrays.
It turns out, however, that these notations are completely compatible.
Consider, for example, the type <tt>A<sup>3</sup></tt>.
This is the type of a function that can be evaluated on three different values and for each value it can take a value of type A.
In other words we can completely specify the function by making an array containing each of the three different values.
In other words <tt>A<sup>3</sup>=A<sup>3</sup></tt> where on the left we mean an array and on the right we mean a function. So we can use this notation without any risk of ambiguity.
Note also that identities like <tt>2<sup>3</sup>=8</tt> make perfect sense.
<p>
</p><h3>The Analysis of Datatypes</h3>
We have introduced 2 concrete types above: <tt>0</tt> and <tt>1</tt> and have shown how to construct other types out of them using addition, multiplication and exponentiation. However, using these types we can only construct types with finite numbers of objects. In practice we often want to work with types that have an infinity of objects. For example the type consisting of binary trees, or lists of binary flags, or even arbitrary integers.

Consider for example the list. A popular definition in C for a list of objects of type <tt>A</tt> is

<blockquote>
<table width="75%">
<tbody><tr>
<td bgcolor="#CCFFFF">
<pre><tt>
typedef struct {
        <tt>A</tt> head;
        Alist *tail;
} Alist;
</tt></pre>
</td>
</tr>
</tbody></table>
</blockquote>

A list consists of a head and a tail. However there is a little C trick being used here. C has a special pointer, the null pointer, and that can be used to indicate the empty list with zero elements. If we didn't have such an object we would have to represent an <tt>Alist</tt> using something like

<blockquote>
<table width="75%">
<tbody><tr>
<td bgcolor="#CCFFFF">
<pre><tt>
typedef union {
        One empty;
        struct {
                <tt>A</tt> head;
                Alist *tail;
        } headAndTail;
} Alist;
</tt></pre>
</td>
</tr>
</tbody></table>
</blockquote>

Let's look at this closely. As described above we consider unions to contain information about which slot is filled. If the <tt>empty</tt> slot is filled we consider the list to be empty (in which case we don't care what the value of <tt>empty</tt> is because there is only one value it could take). If the other slot is filled then we have a non-empty list with head and tail. We can write this very succinctly as:

<blockquote>
<table width="75%">
<tbody><tr>
<td bgcolor="#CCFFFF">
<pre><tt>
L = 1+A.L
</tt></pre>
</td>
</tr>
</tbody></table>
</blockquote>

So we have an algebraic equation defining <tt>L</tt>. More generally we can consider lists containing different types of objects so <tt>L</tt> is really a function of <tt>A</tt>.

<blockquote>
<table width="75%">
<tbody><tr>
<td bgcolor="#CCFFFF">
<pre><tt>
L[A] = 1+A.L[A]
</tt></pre>
</td>
</tr>
</tbody></table>
</blockquote>

In C++ we'd call <tt>L[.]</tt> a template.
<p>
Now consider what forms a list can take.
It can consist of a list with no elements, or a list with one element of type <tt>A</tt>, or two elements of type <tt>A</tt> and so on.
On other words we can think of <tt>L[A]=1+A+A<sup>2</sup>+A<sup>3</sup>+...</tt>. (Note that we haven't defined what we mean by an infinite sum so just read this as suggestive.) We can get this in a different way.
From the above equation we have

</p><blockquote>
<table width="75%">
<tbody><tr>
<td bgcolor="#CCFFFF">
<pre><tt>
L[A]-A.L[A]=1 </tt>(We haven't defined minus but let's pretend we can do this)<tt>
L[A].(1-A)=1
L[A]=1/(1-A) </tt>(We haven't defined division either)<tt>
    =1+A+A<sup>2</sup>+A<sup>3</sup>+... </tt>(By the binomial expansion)<tt>
</tt></pre>
</td>
</tr>
</tbody></table>
</blockquote>

So amazingly, even though we have used operations that don't make much sense here, we have succeeded in extracting meaningful results. There are ways of making these arguments rigorous but that isn't my intention here. In general subtraction and division are not allowed.
<p>
Let's consider a different type: binary trees where the leaves contain objects of type <tt>A</tt>. A binary tree is either a leaf, in which case it contains an object of type <tt>A</tt>, or it contains two child trees. In other words we can write

</p><blockquote>
<table width="75%">
<tbody><tr>
<td bgcolor="#CCFFFF">
<pre><tt>
T[A] = A+T[A]<sup>2</sup>
</tt></pre>
</td>
</tr>
</tbody></table>
</blockquote>

We might wish to work with binary trees that are just trees i.e. don't contain any data in their leaf nodes.
These are objects of type <tt>T=T[1]</tt> where <tt>T=1+T<sup>2</sup></tt>.
<p>
There is a remarkable identity we can prove about such binary trees <a href="#1">[1]</a>:

</p><blockquote>
<table width="75%">
<tbody><tr>
<td bgcolor="#CCFFFF">
<pre><tt>
T<sup>7</sup> = T<sup>6</sup>.T = T<sup>6</sup>.(1+T<sup>2</sup>) = T<sup>6</sup>+T<sup>8</sup>
   = T<sup>5</sup>+T<sup>7</sup>+T<sup>8</sup>
   .
   .
   .
   = 1+T+T<sup>2</sup>+T<sup>4</sup>
   = 1+T+T<sup>3</sup>
   = 1+T<sup>2</sup>
   = T (Details form an exercise.)
</tt></pre>
</td>
</tr>
</tbody></table>
</blockquote>

In other words the type of binary trees is isomorphic to the type of arrays of 7 trees! It is possible to write a simple piece of code that maps every array of 7 binary trees uniquely to a single tree in a nice way and vice versa.
<p>
Notice that we can also compose datatypes. So using the above notation <tt>L[T[X]]</tt> is the type of lists of trees of <tt>X</tt>'s.

</p><h3>The Calculus of Datatypes <a href="#2">[2]</a></h3>
Many computer languages define the notion of a pointer. For example given a doubly linked list we can obtain a pointer to the first element and then walk back and forth through the list by following the pointers associated with each element.
<p>
In some programming languages, however, in particular the pure functional languages such as Haskell, there is no such thing as a pointer. Often this doesn't matter as algorithms that operate on lists have no need for anything like a pointer. They can be written recursively in terms of two functions: <tt>head(.)</tt> which returns the first element of the list and <tt>tail(.)</tt> which returns the list with the first element removed. Unfortunately there come times when it is more efficient to be able to specify a position in the list and walk backwards and forwards through it. We need to find a way to express a pair consisting of a list and a position in the list in a way that doesn't use pointers. An obvious choice is to represent the position simply as an integer representing a position in the list. To walk left and right we decrement and increment it. But to actually find the value at the nth position entails computing the tail of the list n-1 times.
</p><p>
Here's an approach: to represent a list <tt>l</tt> of type <tt>L[X]</tt> and a pointer to the nth position, use a triple consisting of <tt>(A,x,B)</tt> where <tt>x</tt> is the value of the nth element of the list (of type <tt>X</tt>), <tt>A</tt> is the sublist of <tt>l</tt> from the first up to the nth element stored <em>backwards</em> and <tt>B</tt> is the sublist starting at the n+1-th position and ending at the end of <tt>l</tt>.
We can define <tt>left(A,x,B)=(tail(A),head(A),x::B)</tt> (where <tt>a::b</tt> means the list with <tt>a</tt> as head and <tt>b</tt> as tail). <tt>right(.)</tt> is defined similarly. Note how we can now walk back and forth in the list easily by iterating <tt>left(.</tt>) and <tt>right(.)</tt>.
So these triples serve nicely to replace the original list with a pointer into it. The type of these triples is <tt>X.L<sup>2</sup></tt>. Notice the <tt>X</tt> factor in that. We can drop that by considering instead the type of 'lists with a pointer to an excised element'. This set is simply <tt>L<sup>2</sup></tt>. So how, in general, do we get from a type <tt>F[X]</tt> to the type <tt>F'[X]</tt> coresponding to an <tt>F[X]</tt> with an <tt>X</tt> excised from it?
</p><p>
Consider first the datastructure <tt>Y=X</tt>. There is only one possibility, the pointer has to point at the one instance of an <tt>X</tt> in <tt>Y</tt>. So <tt>F'[X]=1</tt>.
</p><p>
Consider the case <tt>Y=A.X</tt> where <tt>A</tt> is another datastructure not containing an <tt>X</tt>. Since the excised <tt>X</tt> can't be in the <tt>A</tt> then there's only one place it can be. So <tt>F'[X]=A.1=A</tt>.
</p><p>
Now consider <tt>Y=A[X]+B[X]</tt>. The <tt>Y</tt> is either an <tt>A</tt> or a <tt>B</tt> so the excised <tt>X</tt> is either an <tt>A'</tt> or a <tt>B'</tt>. So <tt>F'[X]=A'[X]+B[X]'</tt>.
</p><p>
Now consider the product structure. <tt>F[X]=A[X].B[X]</tt> is a pair consisting of an <tt>A</tt> or a <tt>B</tt> each of which may contain an <tt>X</tt>. An excised <tt>X</tt> lies in <tt>A</tt> or in <tt>B</tt>. If it lies in <tt>A</tt> then that part is represented by <tt>A'</tt> and the <tt>B</tt> is untouched. i.e. we have <tt>A'[X]B[X]</tt>. Conversely we might have <tt>A[X]B'[X]</tt>. So <tt>F'[X]=A[X]B'[X]+A'[X]B[X]</tt>.
</p><p>
Lastly consider composed types such as lists of trees. An object of type <tt>F[G[X]]</tt> is an <tt>F</tt> of <tt>G</tt>'s of <tt>X</tt>'s. To excise an <tt>X</tt> from this we must first choose which of the <tt>G</tt>'s in the <tt>F</tt> contain the excised <tt>X</tt> and then excise an <tt>X</tt> from it. The first choice is <tt>F'[G[X]]</tt> and the second is a <tt>G'[X]</tt>. Our datastructure contains both of these and therefore is of type <tt>F'[G[X]].G'[X]</tt>.
</p><p>
This should be looking familiar. These are the familiar Leibniz rule and chain rule for differentiating algebraic expressions.
</p><p>
Let's try some concrete classes. Consider the datatype that is a triple of objects of type <tt>X</tt>.
In other words <tt>F[X]=X<sup>3</sup></tt>.
The derivative is <tt>3.X<sup>2</sup></tt>.
Now consider how you would represent the excision of an <tt>X</tt> from a triple.
First you'd need to indicate which of the three members had been excised.
Then you need to represent the other two members of the triple.
In other words <tt>3.X<sup>2</sup></tt>.
</p><p>
Now we'll try a more complex example, the list. We have

</p><blockquote>
<table width="75%">
<tbody><tr>
<td bgcolor="#CCFFFF">
<pre><tt>
L[X] = 1+X.L[X]
</tt></pre>
</td>
</tr>
</tbody></table>
</blockquote>

so using the usual rules of calculus

<blockquote>
<table width="75%">
<tbody><tr>
<td bgcolor="#CCFFFF">
<pre><tt>
L'[X] = 0+1.L[X]+X.L'[X]
      = L[X]+X.L'[X]
</tt></pre>
</td>
</tr>
</tbody></table>
</blockquote>

Let's do a suggestive computation of <tt>L'[X]</tt> from this:

<blockquote>
<table width="75%">
<tbody><tr>
<td bgcolor="#CCFFFF">
<pre><tt>
L'[X] = L[X]+X.L'[X]
L'[X].(1-X) = L[X]
L'[X] = L[X]/(1-X)
      = L[X]<sup>2</sup> (using the derivation of L[X]=1/(1-X) above)
</tt></pre>
</td>
</tr>
</tbody></table>
</blockquote>

This is exactly the result we had above. In other words it appears that the derivative procedure works with list types too.
<center>
<img src="./Differentiation of Datastructures for Non-Functional Programmers_files/List.gif">
</center>
<p>
Let's try a more complex example, the binary tree.

</p><blockquote>
<table width="75%">
<tbody><tr>
<td bgcolor="#CCFFFF">
<pre><tt>
T[X] = X+T[X]<sup>2</sup>
T'[X] = 1+2.T[X].T'[X]
</tt></pre>
</td>
</tr>
</tbody></table>
</blockquote>

So an object of type <tt>T'[X]</tt> is either a trivial object of type <tt>1</tt> or a triple consisting of a binary flag, a tree and a tree with an excised <tt>X</tt>.
In fact, these datastructures are well known in functional programming circles as zippers.
<p>
<tt>X.F'[X]</tt> is the second term in the Taylor expansion of <tt>F[X]</tt>. It's actually not that surprising that this represents a type with a marked element.
Suppose the type <tt>F[X+D]</tt> can be expanded in the form

</p><blockquote>
<table width="75%">
<tbody><tr>
<td bgcolor="#CCFFFF">
<pre><tt>
F[X+D] = F0[X]+F1[X].D+F2[X].D<sup>2</sup>+F3[X].D<sup>3</sup>+...
</tt></pre>
</td>
</tr>
</tbody></table>
</blockquote>

where the <tt>Fi[X]</tt> are independent of D.
<p>
Consider what we mean by <tt>F[X+D]</tt>? It's a container of type <tt>F[X]</tt> where some of the <tt>X</tt>'s have been replaced by <tt>D</tt>'s.
It could be none, in which case it is of type <tt>F[X]</tt>. It could have one <tt>D</tt>.
In that case it must be of the form <tt>F1[X].D</tt>. But an object of type <tt>F[X]</tt> with one <tt>X</tt> excised and replaced by a <tt>D</tt> is <tt>F'[X].D</tt>.
So the second term is exactly what we'd expect. Similarly the third term must correspond to two distinct <tt>X</tt>s replaced by <tt>D</tt>s.
From calculus we'd expect <tt>2.F2[X]=F''[X]</tt> and so on.
So now we know how to compute the type of an <tt>F[X]</tt> with n distinct <tt>X</tt>'s excised.

</p><h1>References</h1>
<a name="1">[1]</a> <a href="http://web.archive.org/web/20100630195449/http://www.math.lsa.umich.edu/~ablass/7tree.ps">Seven Trees in One</a>Andreas Blass<br>
<a name="2">[2]</a> <a href="http://web.archive.org/web/20100630195449/http://www.cs.rhul.ac.uk/~conor/diff.ps.gz">The Derivative of a Regular Type is its Type of One-Hole Contexts
</a>Conor McBride







<!--
     FILE ARCHIVED ON 19:54:49 Jun 30, 2010 AND RETRIEVED FROM THE
     INTERNET ARCHIVE ON 13:38:53 Oct 9, 2012.
     JAVASCRIPT APPENDED BY WAYBACK MACHINE, COPYRIGHT INTERNET ARCHIVE.

     ALL OTHER CONTENT MAY ALSO BE PROTECTED BY COPYRIGHT (17 U.S.C.
     SECTION 108(a)(3)).
-->
<div id="sbi_camera_button" class="sbi_search" style="left: 0px; top: 0px; position: absolute; width: 29px; height: 27px; border: none; margin: 0px; padding: 0px; z-index: 2147483647; display: none; "></div></body></html>
