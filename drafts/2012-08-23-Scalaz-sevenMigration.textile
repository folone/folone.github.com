---
layout: post
title: Миграция на scalaz-seven
comments: rue
is: post
categories:
- scala 
- scalaz
- fp
---

Вышел уже третий майлстоун "новой scalaz":https://github.com/scalaz/scalaz/tree/scalaz-seven. Начиная с первого майлстоуна, я перевёл почти все наши проекты на него. Тем не менее, вчера выяснилось, что про пару проектов я забыл. Потому вчера снова проделал миграцию. Пока впечатления свежие, решил записать.
В новой версии изменилось очень многое.

h2. Из core вынесено всё лишнее в отдельные модули.

Например, если вы до того пользовались контролем эффектов, теперь нужно использовать артефакт scalaz-effect. Для iteratees -- scalaz-iteratee, для concurrent -- scalaz-concurrent. Http и geo были выброшены. Но появилась новая классная штука, scalaz-typelevel.

h2. Функции тайпклассов перенесли в их инстансы.

Благодаря этому пропали @Identity@, @MA@ и @MAB@. Также инстансы разных типов теперь определяются в самих типах (раньше -- в тайпклассах). Также синтаксис определения инстансов изменился. Теперь несколько инстансов можно определить в одном @implicit val@'е. Например, вот как выглядит определение инстансов для @NodeSeq@'а:

{% highlight scala %}
implicit val nodeSeqInstance = new Monoid[NodeSeq] with Show[NodeSeq] with Equal[NodeSeq] {
  override def zero = NodeSeq.Empty
  override def append(f1: NodeSeq, f2: ⇒ NodeSeq) = f1 ++ f2
  override def shows(as: NodeSeq) = new PrettyPrinter(80, 2) formatNodes as
  override def equal(a1: NodeSeq, a2: NodeSeq): Boolean = a1 == a2
}
{% endhighlight %}

h2. -Мух- Тайпклассы отделили от -котлет- их синтаксиса.

Благодаря этому код, который работает с функциями, принимающими тайпклассы из scalaz может вообще не знать о юникодных алиасах для функций тайпклассов. Например, для того, чтобы использовать инстансы @Option@'а, достаточно @import scalaz.std.option._@. Теперь можно:

{% highlight scala %}
val monad = implicitly[Monad[Option]] // или просто Monad[Option]
val option: Option[Int] = monad.point(1)
{% endhighlight %}

Работа с инстансами с синтаксисом и без выглядит как-то так:

{% highlight scala %}
val monad = implicitly[Monad[Option]] // или просто Monad[Option]
val optopt: Option[Option[Int]] = Some(Some(1))

// Without syntax
val opt = monad.join(opyopt)

// With syntax
import syntax.monad._
val opt = optopt.join
{% endhighlight %}